{
  "modulesPage": {
    "description": {
      "makeNewTools": "「模块」功能透过将本模拟器中现有的工具所建立的物件进行组合、特化或重新参数化，来制作新的工具。",
      "appearAsTools": "导入的模块将显示为「其他」类别中的工具。请选择并依照控制点顺序点击空白处（参见「规格」）。",
      "embeddedInScene": "导入的模块将嵌入于场景的数据中，所以当原作者更新时并不会自动更新。"
    },
    "import": "导入",
    "imported": "已导入",
    "specification": {
      "title": "规格",
      "controlPointSequence": "控制点顺序",
      "parameters": "参数"
    },
    "customization": {
      "title": "客制化",
      "description": "您可直接在本网页程序中使用内置的JSON编辑器制作或客制化模块。请参见[教程](/modules/tutorial)。将导入的模块客制化仅会影响目前的场景。"
    },
    "contribution": {
      "title": "贡献",
      "description": "欢迎您贡献项目至以上的清单。欲贡献您的模块，请参见[貢獻模块](/contributing/modules)。"
    }
  },
  "moduleData": {
    "FresnelLens": {
      "title": "菲涅耳透镜",
      "description": "从半圆形透光物制成的菲涅耳透镜。[此作品集范例](/gallery/fresnel-lens)的模块化版本。",
      "point1": "透镜的第一个端点",
      "point2": "透镜的第二个端点",
      "Nslice": "切片数量",
      "refIndex": "透镜的折射率"
    },
    "ContSpectrum": {
      "title": "连续光谱光源",
      "description": "具有均匀连续光谱的光源，以指定的步长离散化。只在「模拟色彩」模式中运作。",
      "point1": "光线的起点",
      "point2": "决定光线的方向",
      "min": "波长最小值",
      "step": "波长的步长",
      "max": "波长最大值",
      "brightness": "总亮度"
    },
    "CoatedLens": {
      "title": "镀膜球面透镜",
      "description": "两面具有单层涂层的球面透镜。嵌入于本模块中的 `ArcCoating` 模块代表一个薄膜层，其与透光物的表面重叠时，会成为该透光物的涂层。",
      "point1": "透镜的中心",
      "h": "透镜的高度",
      "d": "透镜的厚度",
      "R1": "前表面的曲率半径",
      "R2": "后表面的曲率半径",
      "A": "透镜材料的柯西系数 \\(A\\)",
      "B": "透镜材料的柯西系数 \\(B\\)（以平方微米为单位）",
      "dc": "涂层的厚度（以纳米为单位）",
      "Ac": "涂层材料的柯西系数 \\(A\\)",
      "Bc": "涂层材料的柯西系数 \\(B\\)（以平方微米为单位）"
    },
    "CircleSource": {
      "title": "圆形光源",
      "description": "将一系列均匀的180度点光源置于圆周上所形成的光源。",
      "point1": "该圆形的圆心",
      "r": "该圆形的半径",
      "N": "点光源的数量",
      "brightness": "总亮度"
    },
    "EllipticalMirror": {
      "title": "椭圆镜",
      "description": "由两个焦点和半长轴长度所定义的椭圆形镜子。",
      "point1": "第一个焦点",
      "point2": "第二个焦点",
      "a": "半长轴的长度",
      "tMin": "曲线的最小角度",
      "tMax": "曲线的最大角度",
      "tStep": "曲线的步长"
    },
    "Chaff": {
      "title": "干扰箔",
      "description": "矩形的干扰箔，由许多随机的镜子组成。[此作品集范例](/gallery/chaff-countermeasure)的模块化版本。",
      "point1": "干扰箔的左上角",
      "point2": "干扰箔的右下角",
      "N": "干扰箔中镜子的数量",
      "L": "镜子的长度"
    },
    "BeamExpander": {
      "title": "扩束镜",
      "description": "两个理想透镜的组合，使得两者焦距之和等于两者间的距离。此组合可以扩大或缩小准直光束的直径[此作品集范例](/gallery/beam-expanders)的模块化版本。",
      "point1": "第一个透镜的中心点",
      "point2": "第二个透镜的第二个点",
      "point3": "决定共同焦点的位置"
    },
    "RayRelay": {
      "title": "光线中继",
      "description": "一系列相同的理想透镜，焦距为 \\(f\\)，间距为 \\(d\\)。若且唯若\\(d\\leq 4f\\)时，可以保证光线轨迹不会发散。[此作品集范例](/gallery/ray-relaying)的模块化版本。",
      "point1": "第一个透镜的第一个端点",
      "point2": "第一个透镜的第二个端点（应与第一点有相同的 \\(x\\)）",
      "f": "透镜的焦距",
      "d": "透镜之间的距离",
      "N": "透镜的数量"
    },
    "OpticalFiber": {
      "title": "光纤",
      "description": "指定核心和包层折射率的线状光纤。",
      "point1": "光纤的第一个端点",
      "point2": "光纤的第二个端点",
      "X": "核心的厚度",
      "Y": "包层的厚度",
      "n1": "核心的折射率",
      "n2": "包层的折射率"
    },
    "CubeBeamSplitter": {
      "title": "立方体分束器",
      "description": "立方体分束器是常见的光学元件。此模组可以调整立方体的大小和角度。",
      "point1": "立方体（正方形）的中心",
      "size": "立方体的大小",
      "angle": "立方体的旋转角度（以度为单位）",
      "refIndex": "立方体的折射率（或当「模拟色彩」开启时的柯西系数 \\(A\\)）",
      "cauchyB": "立方体的柯西系数 \\(B\\)（以平方微米为单位）",
      "splitRatio": "对角线分光镜的透光率"
    }
  },
  "moduleTutorial": {
    "title": "「射线光学模拟」模块制作教程",
    "opening": {
      "description": "本教程将引导您完成建立自定义模块的基本步骤。这个功能可完全在本模拟器网页程序中实现，而不需要其他的开发环境。",
      "moduleIntroduction": "「线光学模拟」的「模块」功能允许将物件以模块化的方式组合在一起，其中可包含自定义参数、自定义控制点与物件数组。本功能透过将本模拟器中现有的工具所建立的物件进行组合、特化或重新参数化，来制作新的工具，以扩充本模拟器的功能。例如，`CircleSource`模块（请参见工具->其他->导入模块）将现有的「点光源（<360°）」工具所建立的一系列点光源沿着一个圆形组合在一起，成为一个「圆形光源」工具，这在模拟器中原本并不存在。`FresnelLens`模块则是将「透光物->自定义函数」工具特化，使函数表示菲涅耳透镜的特定曲线，由切片数参数化，以制作一个特化的「菲涅耳透镜」工具，这在模拟器中原本也不存在。除了制作新工具外，这个功能还可以使一些光学演示更具互动性。例如，通过拖曳`BeamExpander`模块的第三个控制点，可以直接观察两个透镜的共同焦点位置如何影响光束宽度，而无需分别调整两个透镜的焦距。",
      "compareWithHandle": "注意并非所有的自定义控制点都需要模块。一些简单的情况可能可以通过「控制杆」功能实现（请参见模拟器右下角的帮助弹出窗口中的「群组、旋转和缩放物件」部分）。由于制作模块比建立控制杆复杂得多，您应该在考虑制作模块之前检查您的情况是否可以通过「控制杆」功能实现。比如[这个例子](/gallery/black-cat-becomes-white)展示了一个相对复杂但不必使用模块的自定义控制点（将两个塑料袋从水中移开）。",
      "compareWithIntegrations": "另一方面，如果您需要进行复杂的编程（例如制作动画、使用复杂的算法排列光学元件或对辐照度图进行分析），请改用[整合工具](/integrations)，并编写 Python 或 Julia 脚本。",
      "contribute": "欢迎将您的模块[贡献到「导入模块」列表中](/contributing/modules)！只要您认为这个模块对其他人有帮助，即使是通过 AI 助手写成的也可以。"
    },
    "aiAssistant": {
      "title": "使用 AI 助手",
      "description": "ChatGPT 上的 [Ray Optics Coder](/ai-tools/chatgpt) 可以帮助您编写「射线光学模拟」模块。它会根据您的描述生成场景的 JSON 代码，您只需要将其复制到 JSON 编辑器（见下）即可。您也可以使用它来编辑现有模组或模组化场景。",
      "limitation": "由聊天机器人生成的代码可能无法直接运作。如果出现错误，建议将错误讯息复制到聊天机器人中，可能能够得到解决。对于更复杂的模块，建议您仍然自行阅读以下教学并编写部分代码。",
      "otherServices": "聊天机器人的指引和知识文件可在[这里](/ai-tools/instructions)取得。如果您偏好其他 LLM 服务，您可以提供这些文件，教它如何写出「射线光学模拟」模块。"
    },
    "jsonEditor": {
      "title": "内置的JSON编辑器",
      "currentlyNoVisual": "本应用目前没有用于建立模块的视觉界面，因此您需要直接编辑场景的JSON原始码。",
      "enableJsonEditor": "您可以通过点击应用程序右上角的「设置」下拉菜单，然后勾选「显示JSON编辑器」来启用内置的JSON编辑器。原始码编辑器会出现在界面的左侧，并显示目前场景的JSON原始码。请确保您有足够大的屏幕，因为这个功能在行动装置上效果不佳。",
      "updateAccordingly": "当您使用可视化场景编辑器修改场景时，JSON编辑器中的原始码将自动更新，且更改的部分会突出显示。反之，直接在JSON编辑器中编辑原始码将相应更新场景。如果您不熟悉JSON或任何基于文字的数据格式，您可能会希望花一些时间来熟悉它。",
      "objsArray": "特别是，当您将一个物件新增到场景中时，它将被新增到`objs`数组中。如果您将某些属性修改为非预设值，它们将作为该物件的键值对出现。",
      "disableAutoUpdate": "如果您不希望在编辑JSON时自动更新场景，您可以启用设置 -> 显示模拟器控制列，并取消选择「自动刷新」。当编辑完成时，点击「刷新模拟」（如果您不希望立即重新运行模拟，也可以点击「刷新场景」）。",
      "inIframesBelow": "注意：如果您在本教程页面中看不到下面的iframe中的JSON编辑器，请启用它并重新加载本页，因为您需要查看原始码以了解它的运作方式。"
    },
    "basics": {
      "title": "模块的基本概念",
      "lookAtExample": "让我们看第一个例子。",
      "lookAtJson": "您会看到四段文字。通过查看JSON编辑器，您将看到前两段直接位于顶层的`objs`数组中，但后两段位于`modules.ExampleModule.objs`中。",
      "moduleDef": "`modules`是一个字典，其中键是模块的名称（在本例中是`ExampleModule`），值是该模块的定义。特别是，`modules.ExampleModule.objs`数组描述了该模块中的物件（模板），这与描述场景中的物件的顶层`objs`数组不同。",
      "putToScene": "要将模块中的物件放到场景中，我们需要一个「模块物件」，它位于顶层`objs`数组中，本例中是`objs[2]`，其类型是`ModuleObj`，其`module`属性是模块的名称。",
      "moduleDefNotEditable": "`modules`字典中的模块定义无法由可视化场景编辑器编辑。因此，当您点选本例中的后两段文字时，您只选择了模块物件，而不是模块中的物件。由于本例中模块定义中的文字坐标是绝对坐标，因此后两段文字无法被拖曳。我们将在后面学习到如何使用控制点来使它们可被拖曳。",
      "demodulize": "当您提取模块物件时，物件栏上会有一个「取消模块化」按钮。点选后会将模块物件「展开」为构成此模块的物件，此时`objs`将包含所有四段文字。这个操作是不可逆的（除非点击「复原」）。",
      "createModule": "目前建议制作模块的方式为，首先使用JSON编辑器建立一个空的模块，然后使用可视化场景编辑器新增一些物件，最后使用JSON编辑器将这些物件从`objs`剪下并粘贴到`modules.ModuleName.objs`中。"
    },
    "parameters": {
      "title": "新增参数",
      "lookAtExample": "模块中的物件可以由一组参数来定义。让我们看一个简单的例子",
      "paramsArray": "这里`modules.ModuleName.params`是一个由形如`\"名称=起始值：增量：终止值：预设值\"`的字串构成的数组，定义了变数的名称和数值滑杆的范围。当提取模块物件时，滑杆将出现在物件栏上。",
      "equationSyntax": "在`modules.ExampleModule.objs`数组中，任何值都可以使用这些参数来表示。在字串中（例如`TextLabel`的`text`属性）中，带有参数的数学式被反引号包围。对于数值参数（例如`TextLabel`的`fontSize`属性），您需要将其改为字串，以便您可以在其中使用反引号格式。因此每条数学式都被一对反引号和一对引号包围。这些数学式将使用math.js来计算（[语法](/mathjs/syntax)）。请参见该网页以了解您可以在数学式中使用的语法和函数。",
      "valueStorage": "参数的实际值位于模块物件的`params`属性中。这部分与模块定义不同，其可以通过滑杆直接由可视化场景编辑器编辑。"
    },
    "controlPoints": {
      "title": "新增控制点",
      "lookAtExample": "为了使模块物件可被拖曳，我们需要使用一组控制点来对模块中的物件位置进行参数化。让我们看一个例子",
      "coordinatesOfControlPoints": "这里`modules.ModuleName.numPoints`描述了控制点的数量。控制点坐标之符号为 (`x_1`, `y_1`)、(`x_2`, `y_2`) 等等。其用在`modules.ExampleModule.objs`中的方式与前一节所述之参数相同。请注意索引从1开始。",
      "valueStorage": "控制点的实际值位于模块物件的`controlPoints`属性中，其可以直接由可视化场景编辑器编辑，而非如第一个例子中写死在模块定义中的坐标。每个控制点在场景中显示为两个同心的灰色圆形，并且可以被拖曳。若您拖曳模块物件的其他地方（如文字标签），则所有的控制点会一起移动。",
      "createAsTool": "由于我们的模块物件已经可以移动，我们可以很容易地建立多个实例，就像在本模拟器中其他的工具中一样。模块的名称显示在工具->其他菜单中，您可以选择它，然后按两个点来指定两个控制点的位置，就可建立此模块的另一个实例。您也可以使用物件栏上的「复制」按钮。"
    },
    "arrayAndConditional": {
      "title": "数组与条件",
      "lookAtExample": "使用数组和条件语法，可以建立更复杂的模块。让我们看一个例子",
      "specialKeys": "在`modules.ExampleModule.objs`中，任何数组中的物件都可以有两个特殊的键：`\"for\"`和`\"if\"`。`\"for\"`键的值是一个描述循环变数的字串，格式为`\"名称=起始值：增量：终止值\"`，或者是一个包含多个这种格式的字串的数组，描述多维循环。这样的物件在数组中根据循环变数被复制多次。`\"if\"`键的值是则是一个表示布尔值的字串，使得该物件只在布尔值为真时才会包含在数组中。",
      "preventInfiniteLoop": "为了防止意外的无穷循环，每个`\"for\"`循环的总迭代次数由模块定义中的`maxLoopLength`属性限制，其预设值为1000。如果需要，您可以将此属性设定为更大的值。"
    },
    "variables": {
      "title": "使用变量",
      "lookAtExample": "您可以定义数学变量和函数，以便在整个模块中使用。让我们看一个例子",
      "varsArray": "`modules.ModuleName.vars`是一个字符串数组，每个字符串表示一个math.js语句，其定义一个变量或函数。这些定义按顺序求值，因此后面的定义可以引用前面定义的变量。",
      "context": "变量定义可以引用所有参数和控制点坐标，且被定义后，这些变量可以像参数和控制点坐标一样在对象模板中被引用，从而实现更复杂和可重用的计算。"
    },
    "objsWithEqn": {
      "title": "内置自定义数学式功能的物件",
      "syntax": "对于已经具有自定义数学式输入的物件（例如镜子->自定义函数），JSON中的数学式属性是一个表示LaTeX数学式的字串。要使用math.js来表达这种数学式，并引用模块参数等，您需要将math.js表达式夹在在双反引号中。这种区块会展开为包含自由变量（如 \\(x\\) 对应 `x`，\\(\\theta_0\\) 对应 `theta_0`）的LaTeX数学式。这与单反引号区块不同，单反引號区块不可包含自由变数，且会展开为一个数值。以下例子中，自定义方程式镜子使用了一个包含了自定义参数 `phi` 的数学式",
      "supportedFunctions": "虽然您可以在变数和单反引号区块中使用任何math.js语法和运算，在双反引号区块中，您只能使用目标物件的数学式输入方块所支援的常数、运算子和函数在math.js中的对应（请参见目标物件的资讯框）。您可以使用 `vars` 数组中定义的函数，但函数定义最终也必须由支援的运算组成。",
      "implicitMultiplication": "隐式乘法（例如 `2x`）在这种情况也不允许使用，因为math.js中隐式乘法的运算子优先级没有明确定义。请使用 `*` 运算子明确地表示乘法（例如 `2*x`）。"
    },
    "objsWithShapeParam": {
      "title": "内置形状参数化功能的物件",
      "description": "对于已经支持使用不同方式定义其形状的物件（目前仅有透光物->球面透镜），有特殊的JSON语法可用于在模块定义中用这些方式来定义该物件，即使在顶层`objs`数组中这类的物件总是以形状来定义。以下是一个例子"
    }
  }
}
