{
  "modulesPage": {
    "description": {
      "makeNewTools": "「模組」功能透過將本模擬器中現有的工具所建立的物件進行組合、特化或重新參數化，來製作新的工具。",
      "appearAsTools": "匯入的模組將顯示為「其他」類別中的工具。請選擇並依照控制點順序點擊空白處（參見「規格」）。",
      "embeddedInScene": "匯入的模組將嵌入於場景的資料中，所以當原作者更新時並不會自動更新。"
    },
    "import": "匯入",
    "imported": "已匯入",
    "specification": {
      "title": "規格",
      "controlPointSequence": "控制點順序",
      "parameters": "參數"
    },
    "customization": {
      "title": "客製化",
      "description": "您可直接在本網頁程式中使用內建的 JSON 編輯器製作或客製化模組。請參見[教學](/modules/tutorial)。將匯入的模組客製化僅會影響目前的場景。"
    },
    "contribution": {
      "title": "貢獻",
      "description": "歡迎您貢獻項目至以上的清單。欲貢獻您的模組，請參見[貢獻模組](/contributing/modules)。"
    }
  },
  "moduleData": {
    "FresnelLens": {
      "title": "菲涅耳透鏡",
      "description": "從半圓形透光物製成的菲涅耳透鏡。[此作品集範例](/gallery/fresnel-lens)的模組化版本。",
      "point1": "透鏡的第一個端點",
      "point2": "透鏡的第二個端點",
      "Nslice": "切片數量",
      "refIndex": "透鏡的折射率"
    },
    "ContSpectrum": {
      "title": "連續光譜光源",
      "description": "具有均勻連續光譜的光源，以指定的步長離散化。只在「模擬色彩」模式中運作。",
      "point1": "光線的起點",
      "point2": "決定光線的方向",
      "min": "波長最小值",
      "step": "波長的步長",
      "max": "波長最大值",
      "brightness": "總亮度"
    },
    "CoatedLens": {
      "title": "鍍膜球面透鏡",
      "description": "兩面具有單層塗層的球面透鏡。嵌入於本模組中的`ArcCoating` 模組代表一個薄膜層，其與透光物的表面重疊時，會成為該透光物的塗層。",
      "point1": "透鏡的中心",
      "h": "透鏡的高度",
      "d": "透鏡的厚度",
      "R1": "前表面的曲率半徑",
      "R2": "後表面的曲率半徑",
      "A": "透鏡材料的柯西係數 \\(A\\)",
      "B": "透鏡材料的柯西係數 \\(B\\)（以平方微米為單位）",
      "dc": "塗層的厚度（以奈米為單位）",
      "Ac": "塗層材料的柯西係數 \\(A\\)",
      "Bc": "塗層材料的柯西係數 \\(B\\)（以平方微米為單位）"
    },
    "CircleSource": {
      "title": "圓形光源",
      "description": "將一系列均勻的180度點光源置於圓周上所形成的光源。",
      "point1": "該圓形的圓心",
      "r": "該圓形的半徑",
      "N": "點光源的數量",
      "brightness": "總亮度"
    },
    "EllipticalMirror": {
      "title": "橢圓鏡",
      "description": "由兩個焦點和半長軸長度所定義的橢圓形鏡子。",
      "point1": "第一個焦點",
      "point2": "第二個焦點",
      "a": "半長軸的長度",
      "tMin": "曲線的最小角度",
      "tMax": "曲線的最大角度",
      "tStep": "曲線的步長"
    },
    "Chaff": {
      "title": "干擾箔",
      "description": "矩形的干擾箔，由許多隨機的鏡子組成。[此作品集範例](/gallery/chaff-countermeasure)的模組化版本。",
      "point1": "干擾箔的左上角",
      "point2": "干擾箔的右下角",
      "N": "干擾箔中鏡子的數量",
      "L": "鏡子的長度"
    },
    "BeamExpander": {
      "title": "擴束鏡",
      "description": "兩個理想透鏡的組合，使得兩者焦距之和等於兩者間的距離。此組合可以擴大或縮小準直光束的直徑[此作品集範例](/gallery/beam-expanders)的模組化版本。",
      "point1": "第一個透鏡的中心點",
      "point2": "第二個透鏡的第二個點",
      "point3": "決定共同焦點的位置"
    },
    "RayRelay": {
      "title": "光線中繼",
      "description": "一系列相同的理想透鏡，焦距為 \\(f\\)，間距為 \\(d\\)。若且唯若 \\(d\\leq 4f\\) 時，可以保證光線軌跡不會發散。[此作品集範例](/gallery/ray-relaying)的模組化版本。",
      "point1": "第一個透鏡的第一個端點",
      "point2": "第一個透鏡的第二個端點（應與第一點有相同的 \\(x\\)）",
      "f": "透鏡的焦距",
      "d": "透鏡之間的距離",
      "N": "透鏡的數量"
    },
    "OpticalFiber": {
      "title": "光纖",
      "description": "指定核心和包層折射率的線狀光纖。",
      "point1": "光纖的第一個端點",
      "point2": "光纖的第二個端點",
      "X": "核心的厚度",
      "Y": "包層的厚度",
      "n1": "核心的折射率",
      "n2": "包層的折射率"
    },
    "CubeBeamSplitter": {
      "title": "立方體分束器",
      "description": "立方體分束器是常見的光學元件。此模組可以調整立方體的大小和角度。",
      "point1": "立方體（正方形）的中心",
      "size": "立方體的大小",
      "angle": "立方體的旋轉角度（以度為單位）",
      "refIndex": "立方體的折射率（或當「模擬色彩」開啟時的柯西係數 \\(A\\)）",
      "cauchyB": "立方體的柯西係數 \\(B\\)（以平方微米為單位）",
      "splitRatio": "對角線分光鏡的透光率"
    }
  },
  "moduleTutorial": {
    "title": "「線光學模擬」模組製作教學",
    "opening": {
      "description": "本教學將引導您完成建立自訂模組的基本步驟。這個功能可完全在本模擬器網頁程式中實現，而不需要其他的開發環境。",
      "moduleIntroduction": "「線光學模擬」的「模組」功能允許將物件以模組化的方式組合在一起，其中可包含自訂參數、自訂控制點與物件陣列。本功能透過將本模擬器中現有的工具所建立的物件進行組合、特化或重新參數化，來製作新的工具，以擴充本模擬器的功能。例如，`CircleSource` 模組（請參見工具->其他->匯入模組）將現有的「點光源（<360°）」工具所建立的一系列點光源沿著一個圓形組合在一起，成為一個「圓形光源」工具，這在模擬器中原本並不存在。 `FresnelLens` 模組則是將「透光物->自訂函數」工具特化，使函數表示菲涅耳透鏡的特定曲線，由切片數參數化，以製作一個特化的「菲涅耳透鏡」工具，這在模擬器中原本也不存在。除了製作新工具外，這個功能還可以使一些光學演示更具互動性。例如，通過拖曳 `BeamExpander` 模組的第三個控制點，可以直接觀察兩個透鏡的共同焦點位置如何影響光束寬度，而無需分別調整兩個透鏡的焦距。",
      "compareWithHandle": "注意並非所有的自訂控制點都需要模組。一些簡單的情況可能可以通過「控制桿」功能實現（請參見模擬器右下角的幫助彈出窗口中的「群組、旋轉和縮放物件」部分）。由於製作模組比建立控制桿複雜得多，您應該在考慮製作模組之前檢查您的情況是否可以通過「控制桿」功能實現。比如[這個例子](/gallery/black-cat-becomes-white)展示了一個相對複雜但不必使用模組的自訂控制點（將兩個塑料袋從水中移開）。",
      "compareWithIntegrations": "另一方面，如果您需要進行複雜的編程（例如製作動畫、使用複雜的算法排列光學元件或對輻照度圖進行分析），請改用[整合工具](/integrations)，並編寫 Python 或 Julia 指令碼。",
      "contribute": "歡迎將您的模組[貢獻到「匯入模組」清單中](/contributing/modules)！只要您認為這個模組對其他人有幫助，即使是透過 AI 輔助寫成的也可以。"
    },
    "aiAssistant": {
      "title": "使用 AI 輔助",
      "description": "ChatGPT 上的 [Ray Optics Coder](/ai-tools/chatgpt) 可以幫助您編寫「線光學模擬」模組。它會根據您的描述生成場景的 JSON 程式碼，您只需要將其複製到 JSON 編輯器（見下）即可。您也可以使用它來編輯現有模組或模組化場景。",
      "limitation": "由聊天機器人生成的程式碼可能無法直接運作。如果出現錯誤，建議將錯誤訊息複製到聊天機器人中，可能能夠得到解決。對於更複雜的模組，建議您仍然自行閱讀以下教學並編寫部分程式碼。",
      "otherServices": "聊天機器人的指引和知識檔案可在[這裡](/ai-tools/instructions)取得。如果您偏好其他 LLM 服務，您可以提供這些檔案，教它如何寫出「線光學模擬」模組。"
    },
    "jsonEditor": {
      "title": "內建的 JSON 編輯器",
      "currentlyNoVisual": "本程式目前沒有用於建立模組的視覺界面，因此您需要直接編輯場景的 JSON 原始碼。",
      "enableJsonEditor": "您可以通過點選網頁介面右上角的「設定」下拉選單，然後勾選「顯示 JSON 編輯器」來啟用內建的 JSON 編輯器。原始碼編輯器會出現在介面的左側，並顯示目前場景的 JSON 原始碼。請確保您有足夠大的螢幕，因為這個功能在行動裝置上效果不佳。",
      "updateAccordingly": "當您使用視覺化場景編輯器修改場景時，JSON 編輯器中的原始碼將自動更新，且更改的部分會突出顯示。反之，直接在 JSON 編輯器中編輯原始碼將相應更新場景。如果您不熟悉 JSON 或任何基於文字的資料格式，您可能會希望花一些時間來熟悉它。",
      "objsArray": "特別是，當您將一個物件新增到場景中時，它將被新增到 `objs` 陣列中。如果您將某些屬性修改為非預設值，它們將作為該物件的鍵值對出現。",
      "disableAutoUpdate": "如果您不希望在編輯 JSON 時自動更新場景，您可以啟用設定 -> 顯示模擬器控制列，並取消選擇「自動刷新」。當編輯完成後，點選「刷新模擬」（如果您不希望立即重新運行模擬，也可以點選「刷新場景」）。",
      "inIframesBelow": "注意：如果您在本教學頁面中看不到下面的 iframe 中的 JSON 編輯器，請啟用它並重新載入本頁，因為您需要查看原始碼以了解它的運作方式。"
    },
    "basics": {
      "title": "模組的基本概念",
      "lookAtExample": "讓我們看第一個例子。",
      "lookAtJson": "您會看到四段文字。通過查看 JSON 編輯器，您將看到前兩段直接位於頂層的 `objs` 陣列中，但後兩段位於 `modules.ExampleModule.objs` 中。",
      "moduleDef": "`modules` 是一個字典，其中鍵是模組的名稱（在本例中是 `ExampleModule`），值是該模組的定義。特別是，`modules.ExampleModule.objs` 陣列描述了該模組中的物件（模板），這與描述場景中的物件的頂層 `objs` 陣列不同。",
      "putToScene": "要將模組中的物件放到場景中，我們需要一個「模組物件」，它位於頂層 `objs` 陣列中，本例中是 `objs[2]`，其類型是 `ModuleObj`，其 `module` 屬性是模組的名稱。",
      "moduleDefNotEditable": "`modules` 字典中的模組定義無法由視覺化場景編輯器編輯。因此，當您點選本例中的後兩段文字時，您只選擇了模組物件，而不是模組中的物件。由於本例中模組定義中的文字座標是絕對座標，因此後兩段文字無法被拖曳。我們將在後面學習到如何使用控制點來使它們可被拖曳。",
      "demodulize": "當您選取模組物件時，物件欄上會有一個「取消模組化」按鈕。點選後會將模組物件「展開」為構成此模組的物件，此時 `objs` 將包含所有四段文字。這個操作是不可逆的（除非按「復原」）。",
      "createModule": "目前建議製作模組的方式為，首先使用 JSON 編輯器建立一個空的模組，然後使用視覺化場景編輯器新增一些物件，最後使用 JSON 編輯器將這些物件從 `objs` 剪下並貼上到 `modules.ModuleName.objs` 中。"
    },
    "parameters": {
      "title": "新增參數",
      "lookAtExample": "模組中的物件可以由一組參數來定義。讓我們看一個簡單的例子",
      "paramsArray": "這裡 `modules.ModuleName.params` 是一個由形如 `\"名稱=起始值:增量:終止值:預設值\"`的字串構成的陣列，定義了變數的名稱和數值滑桿的範圍。當選取模組物件時，滑桿將出現在物件欄上。",
      "equationSyntax": "在 `modules.ExampleModule.objs` 陣列中，任何值都可以使用這些參數來表示。在字串中（例如 `TextLabel` 的 `text` 屬性）中，帶有參數的數學式被反引號包圍。對於數值參數（例如 `TextLabel` 的 `fontSize` 屬性），您需要將其改為字串，以便您可以在其中使用反引號格式。因此每條數學式都被一對反引號和一對引號包圍。這些數學式將使用 math.js 來計算（[語法](/mathjs/syntax)）。請參見該網頁以了解您可以在數學式中使用的語法和函數。",
      "valueStorage": "參數的實際值位於模組物件的 `params` 屬性中。這部分與模組定義不同，其可以通過滑桿直接由視覺化場景編輯器編輯。"
    },
    "controlPoints": {
      "title": "新增控制點",
      "lookAtExample": "為了使模組物件可被拖曳，我們需要使用一組控制點來對模組中的物件位置進行參數化。讓我們看一個例子",
      "coordinatesOfControlPoints": "這裡 `modules.ModuleName.numPoints` 描述了控制點的數量。控制點座標之符號為 (`x_1`, `y_1`)、(`x_2`, `y_2`) 等等。其用在 `modules.ExampleModule.objs` 中的方式與前一節所述之參數相同。請注意索引從 1 開始。",
      "valueStorage": "控制點的實際值位於模組物件的 `controlPoints` 屬性中，其可以直接由視覺化場景編輯器編輯，而非如第一個例子中寫死在模組定義中的座標。每個控制點在場景中顯示為兩個同心的灰色圓形，並且可以被拖曳。若您拖曳模組物件的其他地方（如文字標籤），則所有的控制點會一起移動。",
      "createAsTool": "由於我們的模組物件已經可以移動，我們可以很容易地建立多個實例，就像在本模擬器中其他的工具中一樣。模組的名稱顯示在工具->其他選單中，您可以選擇它，然後按兩個點來指定兩個控制點的位置，就可建立此模組的另一個實例。您也可以使用物件欄上的「複製」按鈕。"
    },
    "arrayAndConditional": {
      "title": "陣列與條件",
      "lookAtExample": "使用陣列和條件語法，可以建立更複雜的模組。讓我們看一個例子",
      "specialKeys": "在 `modules.ExampleModule.objs` 中，任何陣列中的物件都可以有兩個特殊的鍵： `\"for\"` 和 `\"if\"`。 `\"for\"` 鍵的值是一個描述迴圈變數的字串，格式為 `\"名稱=起始值:增量:終止值\"`，或者是一個包含多個這種格式的字串的陣列，描述多維迴圈。這樣的物件在陣列中根據迴圈變數被複製多次。`\"if\"` 鍵的值是則是一個表示布林值的字串，使得該物件只在布林值為真時才會包含在陣列中。",
      "preventInfiniteLoop": "為了防止意外的無窮迴圈，每個 `\"for\"` 迴圈的總迭代次數由模組定義中的 `maxLoopLength` 屬性限制，其預設值為 1000。如果需要，您可以將此屬性設定為更大的值。"
    },
    "variables": {
      "title": "使用變數",
      "lookAtExample": "您可以定義數學變數和函數，以便在整個模組中使用。讓我們看一個例子",
      "varsArray": "`modules.ModuleName.vars` 是一個字串陣列，每個字串代表一個 math.js 陳述式，其定義一個變數或函數。這些定義按序求值，因此後面的定義可以引用前面定義的變數。",
      "context": "變數定義可以引用所有參數和控制點座標，且被定義後，這些變數可以像參數和控制點座標一樣在物件模板中被引用，從而實現更複雜和可重用的計算。"
    },
    "objsWithEqn": {
      "title": "內建自訂數學式功能的物件",
      "syntax": "對於已經具有自訂數學式輸入的物件（例如鏡子 -> 自訂函數），JSON 中的數學式屬性是一個表示 LaTeX 數學式的字串。要使用 math.js 來表達這種數學式，並引用模組參數等，您需要將 math.js 表達式夾在在雙反引號中。這種區塊會展開為包含自由變數（如 \\(x\\) 對應 `x`，\\(\\theta_0\\) 對應 `theta_0`）的 LaTeX 數學式。這與單反引號區塊不同，單反引號區塊不可包含自由變數，且會展開為一個數值。以下例子中，自訂方程式鏡子使用了一個包含自訂參數 `phi` 的數學式",
      "supportedFunctions": "雖然您可以在變數和單反引號區塊中使用任何 math.js 語法和運算，在雙反引號區塊中，您只能使用目標物件的數學式輸入方塊所支援的常數、運算子和函數在 math.js 中的對應（請參見目標物件的資訊框）。您可以使用 `vars` 陣列中定義的函數，但函數定義最終也必須由支援的運算組成。",
      "implicitMultiplication": "隱式乘法（例如 `2x`）在這種情況下也不允許使用，因為在 math.js 中隱式乘法的運算子優先級沒有明確定義。請使用 `*` 運算子明確地表示乘法（例如 `2*x`）。"
    },
    "objsWithShapeParam": {
      "title": "內建形狀參數化功能的物件",
      "description": "對於已經支援使用不同方式定義其形狀的物件（目前僅有透光物 -> 球面透鏡），有特殊的 JSON 語法可用於在模組定義中用這些方式來定義該物件，即使在頂層 `objs` 陣列中這類的物件總是以形狀來定義。以下是一個例子"
    }
  }
}
